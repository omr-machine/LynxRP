#pragma kernel CSTransformToWorld           // 0
#pragma kernel CSMatrixMultiply             // 1

#include <HLSLSupport.cginc>
#include "../../ShaderLibrary/Primitives.hlsl"

uint _IndexSize;

RWStructuredBuffer<Vertex> _IndexBuffer;
RWStructuredBuffer<int> _OffsetSizesBuffer;
RWStructuredBuffer<float4x4> _MatricesBuffer;

float3 LocalToWorld(float3 positionLS, float4x4 matLW)
{
    float3 positionWS = mul(matLW, float4(positionLS.xyz, 1.0)).xyz;
    return positionWS;
}

[numthreads(256,1,1)]
void CSTransformToWorld(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _IndexSize)
    {
        return;
    }
    
    uint vertIdxMin = _OffsetSizesBuffer[id.x * 2];
    uint vertIdxMax = vertIdxMin + _OffsetSizesBuffer[id.x * 2 + 1] - 1;
    
    for (uint i = vertIdxMin; i <= vertIdxMax; i++)
    {
        Vertex vertices[3];
        Vertex vertex;
        vertex.position = LocalToWorld(_IndexBuffer[i].position, _MatricesBuffer[id.x]);
        vertex.normal = _IndexBuffer[i].normal;
        vertex.color = _IndexBuffer[i].color;
        vertex.baseUV = _IndexBuffer[i].baseUV;
        
        //vertex.position.y += 10.0;
        
        vertices[i] = vertex;
        _IndexBuffer[i] = vertices[i];
    }
}

[numthreads(256,1,1)]
void CSMatrixMultiply(uint id : SV_DispatchThreadID)
{
    if (id.x >= _IndexSize)
    {
        return;
    }
}
